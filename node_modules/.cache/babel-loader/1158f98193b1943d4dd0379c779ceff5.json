{"ast":null,"code":"function deleteRow(arr, row) {\n  let pos = undefined;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i][0] == row[0] && arr[i][1] == row[1]) {\n      pos = i;\n    }\n  }\n\n  pos += 1;\n  arr = arr.slice(0);\n  arr.splice(pos - 1, 1);\n  return arr;\n}\n\nfunction check(arr, num) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i][0] == num[0] && arr[i][1] == num[1]) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nfunction isWithinTheGrid(x, y, rows, cols) {\n  let condition1 = x >= 0 && x < rows;\n  let condition2 = y >= 0 && y < cols;\n  return condition1 && condition2;\n}\n\nfunction isStartEnd(posX, posY, startNode, endNode) {\n  let condition1 = startNode.x == posX && startNode.y == posY;\n  let condition2 = endNode.x == posX && endNode.y == posY;\n  return condition1 || condition2;\n}\n\nfunction generateNumber(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction getWallIndex(corner, size) {\n  let wallPos = undefined;\n\n  if (size >= 3) {\n    wallPos = generateNumber(corner + 1, corner + size - 2);\n\n    if (wallPos % 2 == 1) {\n      wallPos -= 1;\n    }\n\n    return wallPos;\n  } else {\n    return;\n  }\n}\n\nfunction makeOpening(psudoGrid, x, y, width, heigth, wallX, wallY, rows, cols, walls) {\n  //Total openings\n  let openings = []; //Possible Opening\n\n  let possibleOpening = [[generateNumber(x, wallX - 1), wallY], [generateNumber(wallX + 1, x + width - 1), wallY], [wallX, generateNumber(y, wallY - 1)], [wallX, generateNumber(wallY + 1, y + heigth - 1)]]; //Margin Opening\n\n  let marginOpening = [[x, wallY], [x + width - 1, wallY], [wallX, y], [wallX, y + heigth - 1]]; //Adjecent opening\n\n  let adjOpening = [[x - 1, wallY], [x + width, wallY], [wallX, y - 1], [wallX, y + heigth]];\n\n  for (let i = 0; i < 4; i++) {\n    let adjX = adjOpening[i][0];\n    let adjY = adjOpening[i][1];\n\n    if (isWithinTheGrid(adjX, adjY, rows, cols) && psudoGrid[adjX][adjY] == 0) {\n      psudoGrid[marginOpening[i][0]][marginOpening[i][1]] = 0;\n    } else {\n      openings.push(possibleOpening[i]);\n    }\n  }\n\n  let ignoreIt = generateNumber(0, possibleOpening.length - 1);\n\n  for (let i = 0; i < openings.length; i++) {\n    if (i != ignoreIt) {\n      psudoGrid[openings[i][0]][openings[i][1]] = 0;\n    }\n  }\n}\n\nfunction recursiveDivision_helper(psudoGrid, startNode, endNode, d, width, heigth, rows, cols, walls) {\n  if (width <= 1 || heigth <= 1) {\n    return;\n  }\n\n  let wallX = getWallIndex(d[0], width);\n  let wallY = getWallIndex(d[1], heigth);\n\n  for (let i = d[0]; i < d[0] + width; i++) {\n    if (isStartEnd(i, wallY, startNode, endNode)) {\n      continue;\n    }\n\n    psudoGrid[i][wallY] = 1;\n    walls.push([i, wallY]);\n  }\n\n  for (let i = d[1]; i < d[1] + heigth; i++) {\n    if (isStartEnd(wallX, i, startNode, endNode)) {\n      continue;\n    }\n\n    psudoGrid[wallX][i] = 1;\n    walls.push([wallX, i]);\n  }\n\n  makeOpening(psudoGrid, d[0], d[1], width, heigth, wallX, wallY, rows, cols, walls);\n  recursiveDivision_helper(psudoGrid, startNode, endNode, d, wallX - d[0], wallY - d[1], rows, cols, walls);\n  recursiveDivision_helper(psudoGrid, startNode, endNode, [d[0], wallY + 1], wallX - d[0], d[1] + heigth - wallY - 1, rows, cols, walls);\n  recursiveDivision_helper(psudoGrid, startNode, endNode, [wallX + 1, d[1]], d[0] + width - wallX - 1, wallY - d[1], rows, cols, walls);\n  recursiveDivision_helper(psudoGrid, startNode, endNode, [wallX + 1, wallY + 1], d[0] + width - wallX - 1, d[1] + heigth - wallY - 1, rows, cols, walls);\n}\n\nfunction recursiveDivision(startNode, endNode, rows, cols) {\n  let psudoGrid = new Array(rows);\n  let walls = [];\n\n  for (let i = 0; i < rows; i++) {\n    psudoGrid[i] = new Array(cols);\n\n    for (let j = 0; j < cols; j++) {\n      psudoGrid[i][j] = 0; // 0 indicates empty\n    }\n  } //Marking the boudries as walls\n\n\n  for (let i = 0; i < rows; i++) {\n    psudoGrid[i][0] = 1;\n    walls.push([i, 0]);\n    psudoGrid[i][cols - 1] = 1;\n    walls.push([i, cols - 1]);\n  } //Marking the boudries as walls\n\n\n  for (let j = 0; j < cols; j++) {\n    psudoGrid[0][j] = 1;\n    walls.push([0, j]);\n    psudoGrid[rows - 1][j] = 1;\n    walls.push([rows - 1, j]);\n  }\n\n  recursiveDivision_helper(psudoGrid, startNode, endNode, [1, 1], rows - 2, cols - 2, rows, cols, walls);\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (check(walls, [i, j]) && psudoGrid[i][j] == 0) {\n        walls = deleteRow(walls, [i, j]);\n      }\n    }\n  }\n\n  return walls;\n}\n\nexport default recursiveDivision;","map":{"version":3,"sources":["C:/Users/DELL/Desktop/Pathfinding-Visualizer-ReactJS-master/src/main/components/recursiveDivision/recursiveDivision.js"],"names":["deleteRow","arr","row","pos","undefined","i","length","slice","splice","check","num","isWithinTheGrid","x","y","rows","cols","condition1","condition2","isStartEnd","posX","posY","startNode","endNode","generateNumber","min","max","Math","ceil","floor","random","getWallIndex","corner","size","wallPos","makeOpening","psudoGrid","width","heigth","wallX","wallY","walls","openings","possibleOpening","marginOpening","adjOpening","adjX","adjY","push","ignoreIt","recursiveDivision_helper","d","recursiveDivision","Array","j"],"mappings":"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","sourcesContent":["function deleteRow(arr, row) {\n  let pos = undefined;\n  for( let i=0;i<arr.length;i++ ){\n    if( arr[i][0]==row[0] && arr[i][1]==row[1] ){\n      pos = i;\n    }\n  }\n  \n  pos += 1;\n  \n  arr = arr.slice(0); \n  arr.splice(pos - 1, 1);\n  return arr;\n}\n  \nfunction check( arr, num ){\n  for( let i=0;i<arr.length;i++ ){\n    if( arr[i][0]==num[0] && arr[i][1]==num[1] ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nfunction isWithinTheGrid( x, y, rows, cols ){\n    let condition1 = (x >= 0)&&(x < rows);\n    let condition2 = (y >= 0)&&(y < cols);\n    return (condition1 && condition2);\n}\n\nfunction isStartEnd( posX, posY, startNode, endNode ){\n    let condition1 = (startNode.x == posX)&&(startNode.y == posY);\n    let condition2 = (endNode.x == posX)&&(endNode.y == posY);\n\n    return (condition1 || condition2);\n}\n\nfunction generateNumber( min, max ){\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1) + min); \n}\n\nfunction getWallIndex( corner, size ){\n    let wallPos = undefined;\n    if( size >= 3 ){\n        wallPos = generateNumber(corner+1, corner+size-2);\n        if( wallPos%2 == 1 ){\n            wallPos -= 1;\n        }\n\n        return wallPos;\n    }\n    else{\n        return ;\n    }\n}\n\nfunction makeOpening( psudoGrid, x, y, width, heigth, wallX, wallY, rows, cols, walls ){\n    //Total openings\n    let openings = [];\n    \n    //Possible Opening\n    let possibleOpening = [ [generateNumber(x, wallX-1), wallY], [generateNumber(wallX+1, x+width-1), wallY], [wallX, generateNumber(y, wallY-1)], [wallX, generateNumber(wallY+1, y+heigth-1)] ];\n    \n    //Margin Opening\n    let marginOpening = [ [x, wallY], [x+width-1, wallY], [wallX, y], [wallX, y+heigth-1] ];\n\n    //Adjecent opening\n    let adjOpening = [ [x-1, wallY], [x+width, wallY], [wallX, y-1], [wallX, y+heigth] ];\n\n    for( let i=0;i<4;i++ ){\n        let adjX = adjOpening[i][0];\n        let adjY = adjOpening[i][1];\n\n        if( isWithinTheGrid(adjX, adjY, rows, cols) && psudoGrid[adjX][adjY]==0 ){\n            psudoGrid[marginOpening[i][0]][marginOpening[i][1]] = 0;\n        }\n        else{\n            openings.push( possibleOpening[i] );\n        }\n    }\n\n    let ignoreIt = generateNumber(0, possibleOpening.length - 1);\n\n    for( let i=0; i<openings.length; i++ ){\n        if( i != ignoreIt ){\n            psudoGrid[openings[i][0]][openings[i][1]] = 0;\n        }\n    }\n}\n\nfunction recursiveDivision_helper( psudoGrid, startNode, endNode, d, width, heigth, rows, cols, walls ){\n    if( width<=1 || heigth<=1 ){\n        return;\n    }\n\n    let wallX = getWallIndex(d[0], width);\n    let wallY = getWallIndex(d[1], heigth);\n\n    for( let i=d[0]; i < d[0]+width; i++ ){\n        if( isStartEnd(i, wallY, startNode, endNode) ){\n            continue;\n        }\n\n        psudoGrid[i][wallY] = 1;\n        walls.push( [i, wallY] );\n    }\n\n    for( let i=d[1] ;i < d[1]+heigth ;i++ ){\n        if( isStartEnd(wallX, i, startNode, endNode) ){\n            continue;\n        }\n\n        psudoGrid[wallX][i] = 1;\n        walls.push( [wallX, i] );\n    }\n\n    makeOpening( psudoGrid, d[0], d[1], width, heigth, wallX, wallY, rows, cols, walls );\n\n    recursiveDivision_helper( psudoGrid, startNode, endNode, d, wallX-d[0], wallY-d[1], rows, cols, walls );\n    recursiveDivision_helper( psudoGrid, startNode, endNode, [d[0], wallY+1], wallX-d[0], d[1]+heigth-wallY-1, rows, cols, walls );\n    recursiveDivision_helper( psudoGrid, startNode, endNode, [wallX+1, d[1]], d[0]+width-wallX-1, wallY-d[1], rows, cols, walls );\n    recursiveDivision_helper( psudoGrid, startNode, endNode, [wallX+1, wallY+1], d[0]+width-wallX-1, d[1]+heigth-wallY-1, rows, cols, walls );\n}\n\nfunction recursiveDivision( startNode, endNode, rows, cols ){\n    let psudoGrid = new Array(rows);\n    let walls = [];\n    for( let i=0;i<rows;i++ ){\n      psudoGrid[i] = new Array(cols);\n      for( let j=0;j<cols;j++ ){\n          psudoGrid[i][j] = 0;// 0 indicates empty\n      } \n    }    \n\n    //Marking the boudries as walls\n    for( let i=0;i<rows;i++ ){\n        psudoGrid[i][0] = 1;\n        walls.push( [i, 0] );\n\n        psudoGrid[i][cols-1] = 1;\n        walls.push( [i, cols-1] );\n    }\n\n    //Marking the boudries as walls\n    for( let j=0;j<cols;j++ ){\n        psudoGrid[0][j] = 1;\n        walls.push( [0, j] );\n\n        psudoGrid[rows-1][j] = 1;\n        walls.push( [rows-1, j] );\n    }\n\n    recursiveDivision_helper( psudoGrid, startNode, endNode, [1, 1], rows-2, cols-2, rows, cols, walls );\n\n    for( let i=0;i<rows;i++ ){\n        for( let j=0;j<cols;j++ ){\n            if( check(walls, [i, j]) && psudoGrid[i][j]==0 ){\n                walls = deleteRow(walls, [i, j] );\n            }\n        }\n    }\n\n    return walls;\n}\n\nexport default recursiveDivision;\n"]},"metadata":{},"sourceType":"module"}