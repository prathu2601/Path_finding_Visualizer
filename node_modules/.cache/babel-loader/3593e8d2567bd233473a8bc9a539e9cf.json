{"ast":null,"code":"function astar(startNode, endNode) {\n  let q = [];\n  let visited = [];\n  let finalPath = [];\n  q.push(startNode);\n\n  while (q.length > 0) {\n    let minPos = 0;\n\n    for (let i = 0; i < q.length; i++) {\n      if (q[i].score < q[minPos].score) {\n        minPos = i;\n      }\n    }\n\n    let current = q[minPos];\n\n    if (current == endNode) {\n      console.log(\"Done Done Done !!!\");\n      let temp = current;\n      finalPath.push(temp);\n\n      while (temp.previous) {\n        finalPath.push(temp.previous);\n        temp = temp.previous;\n      }\n\n      return {\n        finalPath,\n        visited\n      };\n    }\n\n    q = q.filter(elt => elt !== current);\n    visited.push(current);\n\n    for (let nbPos = 0; nbPos < current.neighbors.length; nbPos++) {\n      let neighbor = current.neighbors[nbPos];\n\n      if (document.getElementById(`node-${neighbor.x}-${neighbor.y}`).className == 'node-wall') {\n        continue;\n      }\n\n      if (!visited.includes(neighbor)) {\n        let temp_gScore = current.gScore + 1;\n        let newPath = false;\n\n        if (q.includes(neighbor)) {\n          if (temp_gScore < neighbor.gScore) {\n            neighbor.gScore = temp_gScore;\n            newPath = true;\n          }\n        } else {\n          neighbor.gScore = temp_gScore;\n          newPath = true;\n          q.push(neighbor);\n        }\n\n        if (newPath) {\n          neighbor.hScore = heruistic(neighbor, endNode);\n          neighbor.score = neighbor.gScore + neighbor.hScore;\n          neighbor.previous = current;\n        }\n      }\n    }\n  }\n\n  return {\n    finalPath,\n    visited,\n    error: 'No Path Found!!!'\n  };\n}\n\nfunction heruistic(start, end) {\n  let dx = Math.abs(start.x - end.x) * Math.abs(start.x - end.x);\n  let dy = Math.abs(start.y - end.y) * Math.abs(start.y - end.y);\n  return Math.sqrt(dx + dy);\n}\n\nexport default astar;","map":{"version":3,"sources":["D:/PM/New folder/Pathfinding-Visualizer-ReactJS-master/src/main/components/aStar/a_star.js"],"names":["astar","startNode","endNode","q","visited","finalPath","push","length","minPos","i","score","current","console","log","temp","previous","filter","elt","nbPos","neighbors","neighbor","document","getElementById","x","y","className","includes","temp_gScore","gScore","newPath","hScore","heruistic","error","start","end","dx","Math","abs","dy","sqrt"],"mappings":"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","sourcesContent":["function astar( startNode, endNode ){\n    let q = [];\n    let visited = [];\n    let finalPath = [];\n\n    q.push(startNode);\n    while( q.length > 0 ){\n        let minPos = 0;\n        for( let i=0;i<q.length;i++ ){\n            if( q[i].score < q[minPos].score ){\n                minPos = i;\n            }\n        }\n\n        let current = q[minPos];\n        if( current == endNode ){\n            console.log(\"Done Done Done !!!\");\n\n            let temp = current;\n            finalPath.push(temp);\n            while( temp.previous ){\n                finalPath.push(temp.previous);\n                temp = temp.previous;\n            }\n\n            return {finalPath, visited};\n        }\n\n        q = q.filter(elt => elt!==current);\n        visited.push(current);\n\n        for( let nbPos = 0; nbPos < current.neighbors.length ; nbPos++ ){\n            let neighbor = current.neighbors[nbPos];\n\n            if( document.getElementById(`node-${neighbor.x}-${neighbor.y}`).className == 'node-wall' ){\n                continue;\n            }\n\n            if( !visited.includes(neighbor) ){\n                let temp_gScore = current.gScore + 1;\n                let newPath = false;\n                if( q.includes(neighbor) ){\n                    if( temp_gScore < neighbor.gScore ){\n                        neighbor.gScore = temp_gScore;\n                        newPath = true;\n                    }\n                }\n                else{\n                    neighbor.gScore = temp_gScore;\n                    newPath = true;\n                    q.push(neighbor);\n                }\n\n                if( newPath ){\n                    neighbor.hScore = heruistic(neighbor, endNode);\n                    neighbor.score = neighbor.gScore + neighbor.hScore;\n                    neighbor.previous = current;\n                }\n            }\n        }\n    }\n\n    return {finalPath, visited, error:'No Path Found!!!'};\n}\n\nfunction heruistic( start, end ){\n    let dx = Math.abs(start.x - end.x) * Math.abs(start.x - end.x);\n    let dy = Math.abs(start.y - end.y) * Math.abs(start.y - end.y);\n    return Math.sqrt( dx + dy );\n}\n\nexport default astar;\n"]},"metadata":{},"sourceType":"module"}