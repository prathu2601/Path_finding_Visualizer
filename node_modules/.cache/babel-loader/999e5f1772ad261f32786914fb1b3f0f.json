{"ast":null,"code":"function deleteRow(arr, row) {\n  let pos = undefined;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i][0] == row[0] && arr[i][1] == row[1]) {\n      pos = i;\n    }\n  }\n\n  pos += 1;\n  arr = arr.slice(0);\n  arr.splice(pos - 1, 1);\n  return arr;\n}\n\nfunction check(arr, num) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i][0] == num[0] && arr[i][1] == num[1]) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nfunction isWithinTheGrid(x, y, rows, cols) {\n  let condition1 = x >= 0 && x < rows;\n  let condition2 = y >= 0 && y < cols;\n  return condition1 && condition2;\n}\n\nfunction isStartEnd(posX, posY, startNode, endNode) {\n  let condition1 = startNode.x == posX && startNode.y == posY;\n  let condition2 = endNode.x == posX && endNode.y == posY;\n  return condition1 || condition2;\n}\n\nfunction generateNumber(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction checkAdjPos(psudoGrid, x, y, width, height, checkList, notWalls) {\n  let direction = [];\n\n  if (x > 0) {\n    if (psudoGrid[2 * (x - 1) + 1][2 * y + 1] === 1) {\n      direction.push('L');\n    }\n  }\n\n  if (y > 0) {\n    if (psudoGrid[2 * x + 1][2 * (y - 1) + 1] === 1) {\n      direction.push('U');\n    }\n  }\n\n  if (x < width - 1) {\n    if (psudoGrid[2 * (x + 1) + 1][2 * y + 1] === 1) {\n      direction.push('R');\n    }\n  }\n\n  if (y < height - 1) {\n    if (psudoGrid[2 * x + 1][2 * (y + 1) + 1] === 1) {\n      direction.push('D');\n    }\n  } // console.log(\"$%^&\", direction);\n\n\n  if (direction.length > 0) {\n    let chosenDir = direction[Math.floor(Math.random() * direction.length)]; // console.log(\"###\", chosenDir, direction);\n\n    if (chosenDir === 'L') {\n      checkList.push([x - 1, y]);\n      psudoGrid[2 * x][2 * y + 1] = 0;\n      psudoGrid[2 * (x - 1) + 1][2 * y + 1] = 0;\n      notWalls.push([2 * x, 2 * y + 1]);\n      notWalls.push([2 * (x - 1) + 1, 2 * y + 1]);\n    } else if (chosenDir === 'U') {\n      checkList.push([x, y - 1]);\n      psudoGrid[2 * x + 1][2 * y] = 0;\n      psudoGrid[2 * x + 1][2 * (y - 1) + 1] = 0;\n      notWalls.push([2 * x + 1, 2 * y]);\n      notWalls.push([2 * x + 1, 2 * (y - 1) + 1]);\n    } else if (chosenDir === 'R') {\n      checkList.push([x + 1, y]);\n      psudoGrid[2 * x + 2][2 * y + 1] = 0;\n      psudoGrid[2 * (x + 1) + 1][2 * y + 1] = 0;\n      notWalls.push([2 * x + 2, 2 * y + 1]);\n      notWalls.push([2 * (x + 1) + 1, 2 * y + 1]);\n    } else if (chosenDir === 'D') {\n      checkList.push([x, y + 1]);\n      psudoGrid[2 * x + 1][2 * y + 2] = 0;\n      psudoGrid[2 * x + 1][2 * (y + 1) + 1] = 0;\n      notWalls.push([2 * x + 1, 2 * y + 2]);\n      notWalls.push([2 * x + 1, 2 * (y + 1) + 1]);\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction recursiveBacktracking_helper(psudoGrid, startNode, endNode, width, heigth, rows, cols, notWalls) {\n  let mazeStartX = generateNumber(0, width - 1);\n  let mazeStartY = generateNumber(0, heigth - 1); // console.log(mazeStartX, mazeStartY, \"width : \", width, \"heigth : \", heigth);\n  // console.log(psudoGrid, psudoGrid[2*mazeStartX + 1][2*mazeStartY + 1]);\n\n  psudoGrid[2 * mazeStartX + 1][2 * mazeStartY + 1] = 0;\n  notWalls.push([2 * mazeStartX + 1, 2 * mazeStartY + 1]);\n  let checkList = [];\n  checkList.push([mazeStartX, mazeStartY]);\n\n  while (checkList.length > 0) {\n    // console.log(\"!!!\", psudoGrid, checkList); \n    let size = checkList.length;\n    let topEntry = checkList[size - 1];\n\n    if (!checkAdjPos(psudoGrid, topEntry[0], topEntry[1], width, heigth, checkList, notWalls)) {\n      checkList = deleteRow(checkList, topEntry);\n    }\n  }\n}\n\nfunction recursiveBacktracking(startNode, endNode, rows, cols) {\n  let notWalls = [];\n  let psudoGrid = new Array(rows);\n\n  for (let i = 0; i < rows; i++) {\n    psudoGrid[i] = new Array(cols);\n\n    for (let j = 0; j < cols; j++) {\n      psudoGrid[i][j] = 1; // 0 indicates empty, 1 indicates walls\n    }\n  }\n\n  recursiveBacktracking_helper(psudoGrid, startNode, endNode, (rows - 1) / 2, (cols - 1) / 2, rows, cols, notWalls);\n  return notWalls;\n}\n\nexport default recursiveBacktracking;","map":{"version":3,"sources":["C:/Users/DELL/Desktop/Pathfinding-Visualizer-ReactJS-master/src/main/components/recursiveBacktracking/recursiveBacktracking.js"],"names":["deleteRow","arr","row","pos","undefined","i","length","slice","splice","check","num","isWithinTheGrid","x","y","rows","cols","condition1","condition2","isStartEnd","posX","posY","startNode","endNode","generateNumber","min","max","Math","ceil","floor","random","checkAdjPos","psudoGrid","width","height","checkList","notWalls","direction","push","chosenDir","recursiveBacktracking_helper","heigth","mazeStartX","mazeStartY","size","topEntry","recursiveBacktracking","Array","j"],"mappings":"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","sourcesContent":["\nfunction deleteRow(arr, row) {\n  let pos = undefined;\n  for( let i=0;i<arr.length;i++ ){\n    if( arr[i][0]==row[0] && arr[i][1]==row[1] ){\n      pos = i;\n    }\n  }\n  \n  pos += 1;\n  \n  arr = arr.slice(0); \n  arr.splice(pos - 1, 1);\n  return arr;\n}\n  \nfunction check( arr, num ){\n  for( let i=0;i<arr.length;i++ ){\n    if( arr[i][0]==num[0] && arr[i][1]==num[1] ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nfunction isWithinTheGrid( x, y, rows, cols ){\n    let condition1 = (x >= 0)&&(x < rows);\n    let condition2 = (y >= 0)&&(y < cols);\n    return (condition1 && condition2);\n}\n\nfunction isStartEnd( posX, posY, startNode, endNode ){\n    let condition1 = (startNode.x == posX)&&(startNode.y == posY);\n    let condition2 = (endNode.x == posX)&&(endNode.y == posY);\n\n    return (condition1 || condition2);\n}\n\nfunction generateNumber( min, max ){\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1) + min); \n}\n\nfunction checkAdjPos( psudoGrid, x, y, width, height, checkList, notWalls ){\n    let direction = [];\n    \n    if( x > 0 ){\n        if( psudoGrid[2*(x-1) + 1][2*y + 1] === 1 ){\n            direction.push( 'L' );\n        }\n    }\n    if( y > 0 ){\n        if( psudoGrid[2*x + 1][2*(y-1) + 1] === 1 ){\n            direction.push( 'U' );\n        }\n    }\n    if( x < width-1 ){\n        if( psudoGrid[2*(x+1) + 1][2*y + 1] === 1 ){\n            direction.push( 'R' );\n        }\n    }\n    if( y < height-1 ){\n        if( psudoGrid[2*x + 1][2*(y+1) + 1] === 1 ){\n            direction.push( 'D' );\n        }\n    }\n\n    // console.log(\"$%^&\", direction);\n\n    if( direction.length > 0 ){\n        let chosenDir = direction[Math.floor(Math.random()*direction.length)];\n        // console.log(\"###\", chosenDir, direction);\n        if( chosenDir === 'L' ){\n            checkList.push( [x-1, y] );\n            psudoGrid[2*x][2*y+1] = 0;\n            psudoGrid[2*(x-1)+1][2*y+1] = 0;\n\n            notWalls.push([2*x, 2*y+1]);\n            notWalls.push([2*(x-1)+1, 2*y+1]);\n        }\n        else if( chosenDir === 'U' ){\n            checkList.push( [x, y-1] );\n            psudoGrid[2*x+1][2*y] = 0;\n            psudoGrid[2*x+1][2*(y-1)+1] = 0;\n\n            notWalls.push([2*x+1, 2*y]);\n            notWalls.push([2*x+1, 2*(y-1)+1]);\n        }\n        else if( chosenDir === 'R' ){\n            checkList.push( [x+1, y] );\n            psudoGrid[2*x+2][2*y+1] = 0;\n            psudoGrid[2*(x+1)+1][2*y+1] = 0;\n\n            notWalls.push([2*x+2, 2*y+1]);\n            notWalls.push([2*(x+1)+1, 2*y+1]);\n        }\n        else if( chosenDir === 'D' ){\n            checkList.push( [x, y+1] );\n            psudoGrid[2*x+1][2*y+2] = 0;\n            psudoGrid[2*x+1][2*(y+1)+1] = 0;\n\n            notWalls.push([2*x+1, 2*y+2]);\n            notWalls.push([2*x+1, 2*(y+1)+1]);\n        }\n        return true;\n    }\n    else{\n        return false;\n    }\n}\n\nfunction recursiveBacktracking_helper( psudoGrid, startNode, endNode, width, heigth, rows, cols, notWalls ){\n    let mazeStartX = generateNumber(0, width-1);\n    let mazeStartY = generateNumber(0, heigth-1);\n\n    // console.log(mazeStartX, mazeStartY, \"width : \", width, \"heigth : \", heigth);\n    // console.log(psudoGrid, psudoGrid[2*mazeStartX + 1][2*mazeStartY + 1]);\n    psudoGrid[2*mazeStartX + 1][2*mazeStartY + 1] = 0;\n    notWalls.push([2*mazeStartX + 1, 2*mazeStartY + 1]);\n\n    let checkList = [];\n    checkList.push( [mazeStartX, mazeStartY] );\n\n    while( checkList.length > 0 ){\n        // console.log(\"!!!\", psudoGrid, checkList); \n\n        let size = checkList.length;\n        let topEntry = checkList[size-1];\n\n        if( !(checkAdjPos(psudoGrid, topEntry[0], topEntry[1], width, heigth, checkList, notWalls)) ){\n            checkList = deleteRow( checkList, topEntry );\n        }\n    }\n}\n\nfunction recursiveBacktracking( startNode, endNode, rows, cols ){\n    let notWalls = [];\n\n    let psudoGrid = new Array(rows);\n    for( let i=0;i<rows;i++ ){\n      psudoGrid[i] = new Array(cols);\n      for( let j=0;j<cols;j++ ){\n          psudoGrid[i][j] = 1;// 0 indicates empty, 1 indicates walls\n      } \n    }    \n\n    recursiveBacktracking_helper( psudoGrid, startNode, endNode, (rows-1)/2, (cols-1)/2, rows, cols, notWalls );\n\n    return notWalls;\n}\n\nexport default recursiveBacktracking;\n"]},"metadata":{},"sourceType":"module"}