{"ast":null,"code":"function isWithinTheGrid(X,Y,rows,cols){var condition1=X>=0&&X<rows;var condition2=Y>=0&&Y<cols;return condition1&&condition2;}function dfs(grid,startNode,endNode,rows,cols){var stack=[];var finalPath=[];var visited=[];var nb=[[-1,0],[0,-1],[1,0],[0,1]];stack.push(startNode);var _loop=function _loop(){var size=stack.length;var current=stack.pop();if(current==endNode){console.log(\"Done Done Done !!!\");var temp=current;finalPath.push(temp);while(temp.previous){finalPath.push(temp.previous);temp=temp.previous;}return{v:{finalPath:finalPath,visited:visited}};}stack=stack.filter(function(elt){return elt!==current;});visited.push(current);// console.log(\"_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_\")\n// console.log(\"current : \", current);\nfor(var i=0;i<4;i++){var newX=current.x+nb[i][0];var newY=current.y+nb[i][1];if(isWithinTheGrid(newX,newY,rows,cols)){// console.log(\"corresponding nb : \", newX, newY);\nif(document.getElementById(\"node-\".concat(newX,\"-\").concat(newY)).className!='node-wall'){var newNode=grid[newX][newY];if(!visited.includes(newNode)){// console.log(\"corresponding nb (Inside) : \", newNode);\nstack.push(newNode);newNode.previous=current;}}}}};while(stack.length>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return{finalPath:finalPath,visited:visited,error:'No Path Found!!!'};}export default dfs;","map":{"version":3,"sources":["C:/Users/DELL/Desktop/Pathfinding-Visualizer-ReactJS-master/src/main/components/dfs/dfs.js"],"names":["isWithinTheGrid","X","Y","rows","cols","condition1","condition2","dfs","grid","startNode","endNode","stack","finalPath","visited","nb","push","size","length","current","pop","console","log","temp","previous","filter","elt","i","newX","x","newY","y","document","getElementById","className","newNode","includes","error"],"mappings":"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","sourcesContent":["function isWithinTheGrid( X, Y, rows, cols ){\n    let condition1 = (X >= 0)&&(X < rows);\n    let condition2 = (Y >= 0)&&(Y < cols);\n    return (condition1&&condition2);\n}\n\nfunction dfs( grid, startNode, endNode, rows, cols ){\n    let stack = [];\n    let finalPath = [];\n    let visited = [];\n    let nb = [ [-1, 0], [0, -1], [1, 0], [0, 1] ];\n\n    stack.push(startNode);\n    while( stack.length > 0 ){\n        let size = stack.length;\n        let current  = stack.pop();\n\n        if( current == endNode ){\n            console.log(\"Done Done Done !!!\");\n\n            let temp = current;\n            finalPath.push(temp);\n            while( temp.previous ){\n                finalPath.push(temp.previous);\n                temp = temp.previous;\n            }\n\n            return {finalPath, visited};\n        }\n\n        stack = stack.filter(elt => elt!==current);\n        visited.push(current);\n\n        // console.log(\"_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_\")\n        // console.log(\"current : \", current);\n\n        for( let i=0;i<4;i++ ){\n            let newX = current.x + nb[i][0];\n            let newY = current.y + nb[i][1];\n\n            if( isWithinTheGrid(newX, newY, rows, cols) ){\n                // console.log(\"corresponding nb : \", newX, newY);\n                if( document.getElementById(`node-${newX}-${newY}`).className != 'node-wall' ){\n                    let newNode = grid[newX][newY];\n                    if( !visited.includes(newNode) ){\n                        // console.log(\"corresponding nb (Inside) : \", newNode);\n                        stack.push(newNode);\n                        newNode.previous = current;\n                    }\n                }\n            }\n        }\n    }\n\n    return {finalPath, visited, error:'No Path Found!!!'};\n}\n\nexport default dfs;\n"]},"metadata":{},"sourceType":"module"}