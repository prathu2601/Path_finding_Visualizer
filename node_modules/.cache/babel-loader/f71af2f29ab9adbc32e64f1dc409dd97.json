{"ast":null,"code":"function isWithinTheGrid(X, Y, rows, cols) {\n  let condition1 = X >= 0 && X < rows;\n  let condition2 = Y >= 0 && Y < cols;\n  return condition1 && condition2;\n}\n\nfunction dfs(grid, startNode, endNode, rows, cols) {\n  let stack = [];\n  let finalPath = [];\n  let visited = [];\n  let nb = [[-1, 0], [0, -1], [1, 0], [0, 1]];\n  stack.push(startNode);\n\n  while (stack.length > 0) {\n    let size = stack.length;\n    let current = stack.pop();\n\n    if (current == endNode) {\n      console.log(\"Done Done Done !!!\");\n      let temp = current;\n      finalPath.push(temp);\n\n      while (temp.previous) {\n        finalPath.push(temp.previous);\n        temp = temp.previous;\n      }\n\n      return {\n        finalPath,\n        visited\n      };\n    }\n\n    stack = stack.filter(elt => elt !== current);\n    visited.push(current); // console.log(\"_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_\")\n    // console.log(\"current : \", current);\n\n    for (let i = 0; i < 4; i++) {\n      let newX = current.x + nb[i][0];\n      let newY = current.y + nb[i][1];\n\n      if (isWithinTheGrid(newX, newY, rows, cols)) {\n        // console.log(\"corresponding nb : \", newX, newY);\n        if (document.getElementById(`node-${newX}-${newY}`).className != 'node-wall') {\n          let newNode = grid[newX][newY];\n\n          if (!visited.includes(newNode)) {\n            // console.log(\"corresponding nb (Inside) : \", newNode);\n            stack.push(newNode);\n            newNode.previous = current;\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    finalPath,\n    visited,\n    error: 'No Path Found!!!'\n  };\n}\n\nexport default dfs;","map":{"version":3,"sources":["D:/PM/New folder/Pathfinding-Visualizer-ReactJS-master/src/main/components/dfs/dfs.js"],"names":["isWithinTheGrid","X","Y","rows","cols","condition1","condition2","dfs","grid","startNode","endNode","stack","finalPath","visited","nb","push","length","size","current","pop","console","log","temp","previous","filter","elt","i","newX","x","newY","y","document","getElementById","className","newNode","includes","error"],"mappings":"AAAA,SAASA,eAAT,CAA0BC,CAA1B,EAA6BC,CAA7B,EAAgCC,IAAhC,EAAsCC,IAAtC,EAA4C;AACxC,MAAIC,UAAU,GAAIJ,CAAC,IAAI,CAAN,IAAWA,CAAC,GAAGE,IAAhC;AACA,MAAIG,UAAU,GAAIJ,CAAC,IAAI,CAAN,IAAWA,CAAC,GAAGE,IAAhC;AACA,SAAQC,UAAU,IAAEC,UAApB;AACH;;AAED,SAASC,GAAT,CAAcC,IAAd,EAAoBC,SAApB,EAA+BC,OAA/B,EAAwCP,IAAxC,EAA8CC,IAA9C,EAAoD;AAChD,MAAIO,KAAK,GAAG,EAAZ;AACA,MAAIC,SAAS,GAAG,EAAhB;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,EAAE,GAAG,CAAE,CAAC,CAAC,CAAF,EAAK,CAAL,CAAF,EAAW,CAAC,CAAD,EAAI,CAAC,CAAL,CAAX,EAAoB,CAAC,CAAD,EAAI,CAAJ,CAApB,EAA4B,CAAC,CAAD,EAAI,CAAJ,CAA5B,CAAT;AAEAH,EAAAA,KAAK,CAACI,IAAN,CAAWN,SAAX;;AACA,SAAOE,KAAK,CAACK,MAAN,GAAe,CAAtB,EAAyB;AACrB,QAAIC,IAAI,GAAGN,KAAK,CAACK,MAAjB;AACA,QAAIE,OAAO,GAAIP,KAAK,CAACQ,GAAN,EAAf;;AAEA,QAAID,OAAO,IAAIR,OAAf,EAAwB;AACpBU,MAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ;AAEA,UAAIC,IAAI,GAAGJ,OAAX;AACAN,MAAAA,SAAS,CAACG,IAAV,CAAeO,IAAf;;AACA,aAAOA,IAAI,CAACC,QAAZ,EAAsB;AAClBX,QAAAA,SAAS,CAACG,IAAV,CAAeO,IAAI,CAACC,QAApB;AACAD,QAAAA,IAAI,GAAGA,IAAI,CAACC,QAAZ;AACH;;AAED,aAAO;AAACX,QAAAA,SAAD;AAAYC,QAAAA;AAAZ,OAAP;AACH;;AAEDF,IAAAA,KAAK,GAAGA,KAAK,CAACa,MAAN,CAAaC,GAAG,IAAIA,GAAG,KAAGP,OAA1B,CAAR;AACAL,IAAAA,OAAO,CAACE,IAAR,CAAaG,OAAb,EAlBqB,CAoBrB;AACA;;AAEA,SAAK,IAAIQ,CAAC,GAAC,CAAX,EAAaA,CAAC,GAAC,CAAf,EAAiBA,CAAC,EAAlB,EAAsB;AAClB,UAAIC,IAAI,GAAGT,OAAO,CAACU,CAAR,GAAYd,EAAE,CAACY,CAAD,CAAF,CAAM,CAAN,CAAvB;AACA,UAAIG,IAAI,GAAGX,OAAO,CAACY,CAAR,GAAYhB,EAAE,CAACY,CAAD,CAAF,CAAM,CAAN,CAAvB;;AAEA,UAAI1B,eAAe,CAAC2B,IAAD,EAAOE,IAAP,EAAa1B,IAAb,EAAmBC,IAAnB,CAAnB,EAA6C;AACzC;AACA,YAAI2B,QAAQ,CAACC,cAAT,CAAyB,QAAOL,IAAK,IAAGE,IAAK,EAA7C,EAAgDI,SAAhD,IAA6D,WAAjE,EAA8E;AAC1E,cAAIC,OAAO,GAAG1B,IAAI,CAACmB,IAAD,CAAJ,CAAWE,IAAX,CAAd;;AACA,cAAI,CAAChB,OAAO,CAACsB,QAAR,CAAiBD,OAAjB,CAAL,EAAgC;AAC5B;AACAvB,YAAAA,KAAK,CAACI,IAAN,CAAWmB,OAAX;AACAA,YAAAA,OAAO,CAACX,QAAR,GAAmBL,OAAnB;AACH;AACJ;AACJ;AACJ;AACJ;;AAED,SAAO;AAACN,IAAAA,SAAD;AAAYC,IAAAA,OAAZ;AAAqBuB,IAAAA,KAAK,EAAC;AAA3B,GAAP;AACH;;AAED,eAAe7B,GAAf","sourcesContent":["function isWithinTheGrid( X, Y, rows, cols ){\n    let condition1 = (X >= 0)&&(X < rows);\n    let condition2 = (Y >= 0)&&(Y < cols);\n    return (condition1&&condition2);\n}\n\nfunction dfs( grid, startNode, endNode, rows, cols ){\n    let stack = [];\n    let finalPath = [];\n    let visited = [];\n    let nb = [ [-1, 0], [0, -1], [1, 0], [0, 1] ];\n\n    stack.push(startNode);\n    while( stack.length > 0 ){\n        let size = stack.length;\n        let current  = stack.pop();\n\n        if( current == endNode ){\n            console.log(\"Done Done Done !!!\");\n\n            let temp = current;\n            finalPath.push(temp);\n            while( temp.previous ){\n                finalPath.push(temp.previous);\n                temp = temp.previous;\n            }\n\n            return {finalPath, visited};\n        }\n\n        stack = stack.filter(elt => elt!==current);\n        visited.push(current);\n\n        // console.log(\"_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_\")\n        // console.log(\"current : \", current);\n\n        for( let i=0;i<4;i++ ){\n            let newX = current.x + nb[i][0];\n            let newY = current.y + nb[i][1];\n\n            if( isWithinTheGrid(newX, newY, rows, cols) ){\n                // console.log(\"corresponding nb : \", newX, newY);\n                if( document.getElementById(`node-${newX}-${newY}`).className != 'node-wall' ){\n                    let newNode = grid[newX][newY];\n                    if( !visited.includes(newNode) ){\n                        // console.log(\"corresponding nb (Inside) : \", newNode);\n                        stack.push(newNode);\n                        newNode.previous = current;\n                    }\n                }\n            }\n        }\n    }\n\n    return {finalPath, visited, error:'No Path Found!!!'};\n}\n\nexport default dfs;\n"]},"metadata":{},"sourceType":"module"}