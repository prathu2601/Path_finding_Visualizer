{"ast":null,"code":"function deleteRow(arr,row){var pos=undefined;for(var i=0;i<arr.length;i++){if(arr[i][0]==row[0]&&arr[i][1]==row[1]){pos=i;}}pos+=1;arr=arr.slice(0);arr.splice(pos-1,1);return arr;}function check(arr,num){for(var i=0;i<arr.length;i++){if(arr[i][0]==num[0]&&arr[i][1]==num[1]){return 1;}}return 0;}function isWithinTheGrid(x,y,rows,cols){var condition1=x>=0&&x<rows;var condition2=y>=0&&y<cols;return condition1&&condition2;}function isStartEnd(posX,posY,startNode,endNode){var condition1=startNode.x==posX&&startNode.y==posY;var condition2=endNode.x==posX&&endNode.y==posY;return condition1||condition2;}function generateNumber(min,max){min=Math.ceil(min);max=Math.floor(max);return Math.floor(Math.random()*(max-min+1)+min);}function getWallIndex(corner,size){var wallPos=undefined;if(size>=3){wallPos=generateNumber(corner+1,corner+size-2);if(wallPos%2==1){wallPos-=1;}return wallPos;}else{return;}}function makeOpening(psudoGrid,x,y,width,heigth,wallX,wallY,rows,cols,walls){//Total openings\nvar openings=[];//Possible Opening\nvar possibleOpening=[[generateNumber(x,wallX-1),wallY],[generateNumber(wallX+1,x+width-1),wallY],[wallX,generateNumber(y,wallY-1)],[wallX,generateNumber(wallY+1,y+heigth-1)]];//Margin Opening\nvar marginOpening=[[x,wallY],[x+width-1,wallY],[wallX,y],[wallX,y+heigth-1]];//Adjecent opening\nvar adjOpening=[[x-1,wallY],[x+width,wallY],[wallX,y-1],[wallX,y+heigth]];for(var i=0;i<4;i++){var adjX=adjOpening[i][0];var adjY=adjOpening[i][1];if(isWithinTheGrid(adjX,adjY,rows,cols)&&psudoGrid[adjX][adjY]==0){psudoGrid[marginOpening[i][0]][marginOpening[i][1]]=0;}else{openings.push(possibleOpening[i]);}}var ignoreIt=generateNumber(0,possibleOpening.length-1);for(var _i=0;_i<openings.length;_i++){if(_i!=ignoreIt){psudoGrid[openings[_i][0]][openings[_i][1]]=0;}}}function recursiveDivision_helper(psudoGrid,startNode,endNode,d,width,heigth,rows,cols,walls){if(width<=1||heigth<=1){return;}var wallX=getWallIndex(d[0],width);var wallY=getWallIndex(d[1],heigth);for(var i=d[0];i<d[0]+width;i++){if(isStartEnd(i,wallY,startNode,endNode)){continue;}psudoGrid[i][wallY]=1;walls.push([i,wallY]);}for(var _i2=d[1];_i2<d[1]+heigth;_i2++){if(isStartEnd(wallX,_i2,startNode,endNode)){continue;}psudoGrid[wallX][_i2]=1;walls.push([wallX,_i2]);}makeOpening(psudoGrid,d[0],d[1],width,heigth,wallX,wallY,rows,cols,walls);recursiveDivision_helper(psudoGrid,startNode,endNode,d,wallX-d[0],wallY-d[1],rows,cols,walls);recursiveDivision_helper(psudoGrid,startNode,endNode,[d[0],wallY+1],wallX-d[0],d[1]+heigth-wallY-1,rows,cols,walls);recursiveDivision_helper(psudoGrid,startNode,endNode,[wallX+1,d[1]],d[0]+width-wallX-1,wallY-d[1],rows,cols,walls);recursiveDivision_helper(psudoGrid,startNode,endNode,[wallX+1,wallY+1],d[0]+width-wallX-1,d[1]+heigth-wallY-1,rows,cols,walls);}function recursiveDivision(startNode,endNode,rows,cols){var psudoGrid=new Array(rows);var walls=[];for(var i=0;i<rows;i++){psudoGrid[i]=new Array(cols);for(var j=0;j<cols;j++){psudoGrid[i][j]=0;// 0 indicates empty\n}}//Marking the boudries as walls\nfor(var _i3=0;_i3<rows;_i3++){psudoGrid[_i3][0]=1;walls.push([_i3,0]);psudoGrid[_i3][cols-1]=1;walls.push([_i3,cols-1]);}//Marking the boudries as walls\nfor(var _j=0;_j<cols;_j++){psudoGrid[0][_j]=1;walls.push([0,_j]);psudoGrid[rows-1][_j]=1;walls.push([rows-1,_j]);}recursiveDivision_helper(psudoGrid,startNode,endNode,[1,1],rows-2,cols-2,rows,cols,walls);for(var _i4=0;_i4<rows;_i4++){for(var _j2=0;_j2<cols;_j2++){if(check(walls,[_i4,_j2])&&psudoGrid[_i4][_j2]==0){walls=deleteRow(walls,[_i4,_j2]);}}}return walls;}export default recursiveDivision;","map":{"version":3,"sources":["D:/PM/New folder/Pathfinding-Visualizer-ReactJS-master/src/main/components/recursiveDivision/recursiveDivision.js"],"names":["deleteRow","arr","row","pos","undefined","i","length","slice","splice","check","num","isWithinTheGrid","x","y","rows","cols","condition1","condition2","isStartEnd","posX","posY","startNode","endNode","generateNumber","min","max","Math","ceil","floor","random","getWallIndex","corner","size","wallPos","makeOpening","psudoGrid","width","heigth","wallX","wallY","walls","openings","possibleOpening","marginOpening","adjOpening","adjX","adjY","push","ignoreIt","recursiveDivision_helper","d","recursiveDivision","Array","j"],"mappings":"AAAA,QAASA,CAAAA,SAAT,CAAmBC,GAAnB,CAAwBC,GAAxB,CAA6B,CAC3B,GAAIC,CAAAA,GAAG,CAAGC,SAAV,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAC,CAAX,CAAaA,CAAC,CAACJ,GAAG,CAACK,MAAnB,CAA0BD,CAAC,EAA3B,CAA+B,CAC7B,GAAIJ,GAAG,CAACI,CAAD,CAAH,CAAO,CAAP,GAAWH,GAAG,CAAC,CAAD,CAAd,EAAqBD,GAAG,CAACI,CAAD,CAAH,CAAO,CAAP,GAAWH,GAAG,CAAC,CAAD,CAAvC,CAA4C,CAC1CC,GAAG,CAAGE,CAAN,CACD,CACF,CAEDF,GAAG,EAAI,CAAP,CAEAF,GAAG,CAAGA,GAAG,CAACM,KAAJ,CAAU,CAAV,CAAN,CACAN,GAAG,CAACO,MAAJ,CAAWL,GAAG,CAAG,CAAjB,CAAoB,CAApB,EACA,MAAOF,CAAAA,GAAP,CACD,CAED,QAASQ,CAAAA,KAAT,CAAgBR,GAAhB,CAAqBS,GAArB,CAA0B,CACxB,IAAK,GAAIL,CAAAA,CAAC,CAAC,CAAX,CAAaA,CAAC,CAACJ,GAAG,CAACK,MAAnB,CAA0BD,CAAC,EAA3B,CAA+B,CAC7B,GAAIJ,GAAG,CAACI,CAAD,CAAH,CAAO,CAAP,GAAWK,GAAG,CAAC,CAAD,CAAd,EAAqBT,GAAG,CAACI,CAAD,CAAH,CAAO,CAAP,GAAWK,GAAG,CAAC,CAAD,CAAvC,CAA4C,CAC1C,MAAO,EAAP,CACD,CACF,CACD,MAAO,EAAP,CACD,CAED,QAASC,CAAAA,eAAT,CAA0BC,CAA1B,CAA6BC,CAA7B,CAAgCC,IAAhC,CAAsCC,IAAtC,CAA4C,CACxC,GAAIC,CAAAA,UAAU,CAAIJ,CAAC,EAAI,CAAN,EAAWA,CAAC,CAAGE,IAAhC,CACA,GAAIG,CAAAA,UAAU,CAAIJ,CAAC,EAAI,CAAN,EAAWA,CAAC,CAAGE,IAAhC,CACA,MAAQC,CAAAA,UAAU,EAAIC,UAAtB,CACH,CAED,QAASC,CAAAA,UAAT,CAAqBC,IAArB,CAA2BC,IAA3B,CAAiCC,SAAjC,CAA4CC,OAA5C,CAAqD,CACjD,GAAIN,CAAAA,UAAU,CAAIK,SAAS,CAACT,CAAV,EAAeO,IAAhB,EAAwBE,SAAS,CAACR,CAAV,EAAeO,IAAxD,CACA,GAAIH,CAAAA,UAAU,CAAIK,OAAO,CAACV,CAAR,EAAaO,IAAd,EAAsBG,OAAO,CAACT,CAAR,EAAaO,IAApD,CAEA,MAAQJ,CAAAA,UAAU,EAAIC,UAAtB,CACH,CAED,QAASM,CAAAA,cAAT,CAAyBC,GAAzB,CAA8BC,GAA9B,CAAmC,CAC/BD,GAAG,CAAGE,IAAI,CAACC,IAAL,CAAUH,GAAV,CAAN,CACAC,GAAG,CAAGC,IAAI,CAACE,KAAL,CAAWH,GAAX,CAAN,CACA,MAAOC,CAAAA,IAAI,CAACE,KAAL,CAAWF,IAAI,CAACG,MAAL,IAAiBJ,GAAG,CAAGD,GAAN,CAAY,CAA7B,EAAkCA,GAA7C,CAAP,CACH,CAED,QAASM,CAAAA,YAAT,CAAuBC,MAAvB,CAA+BC,IAA/B,CAAqC,CACjC,GAAIC,CAAAA,OAAO,CAAG7B,SAAd,CACA,GAAI4B,IAAI,EAAI,CAAZ,CAAe,CACXC,OAAO,CAAGV,cAAc,CAACQ,MAAM,CAAC,CAAR,CAAWA,MAAM,CAACC,IAAP,CAAY,CAAvB,CAAxB,CACA,GAAIC,OAAO,CAAC,CAAR,EAAa,CAAjB,CAAoB,CAChBA,OAAO,EAAI,CAAX,CACH,CAED,MAAOA,CAAAA,OAAP,CACH,CAPD,IAQI,CACA,OACH,CACJ,CAED,QAASC,CAAAA,WAAT,CAAsBC,SAAtB,CAAiCvB,CAAjC,CAAoCC,CAApC,CAAuCuB,KAAvC,CAA8CC,MAA9C,CAAsDC,KAAtD,CAA6DC,KAA7D,CAAoEzB,IAApE,CAA0EC,IAA1E,CAAgFyB,KAAhF,CAAuF,CACnF;AACA,GAAIC,CAAAA,QAAQ,CAAG,EAAf,CAEA;AACA,GAAIC,CAAAA,eAAe,CAAG,CAAE,CAACnB,cAAc,CAACX,CAAD,CAAI0B,KAAK,CAAC,CAAV,CAAf,CAA6BC,KAA7B,CAAF,CAAuC,CAAChB,cAAc,CAACe,KAAK,CAAC,CAAP,CAAU1B,CAAC,CAACwB,KAAF,CAAQ,CAAlB,CAAf,CAAqCG,KAArC,CAAvC,CAAoF,CAACD,KAAD,CAAQf,cAAc,CAACV,CAAD,CAAI0B,KAAK,CAAC,CAAV,CAAtB,CAApF,CAAyH,CAACD,KAAD,CAAQf,cAAc,CAACgB,KAAK,CAAC,CAAP,CAAU1B,CAAC,CAACwB,MAAF,CAAS,CAAnB,CAAtB,CAAzH,CAAtB,CAEA;AACA,GAAIM,CAAAA,aAAa,CAAG,CAAE,CAAC/B,CAAD,CAAI2B,KAAJ,CAAF,CAAc,CAAC3B,CAAC,CAACwB,KAAF,CAAQ,CAAT,CAAYG,KAAZ,CAAd,CAAkC,CAACD,KAAD,CAAQzB,CAAR,CAAlC,CAA8C,CAACyB,KAAD,CAAQzB,CAAC,CAACwB,MAAF,CAAS,CAAjB,CAA9C,CAApB,CAEA;AACA,GAAIO,CAAAA,UAAU,CAAG,CAAE,CAAChC,CAAC,CAAC,CAAH,CAAM2B,KAAN,CAAF,CAAgB,CAAC3B,CAAC,CAACwB,KAAH,CAAUG,KAAV,CAAhB,CAAkC,CAACD,KAAD,CAAQzB,CAAC,CAAC,CAAV,CAAlC,CAAgD,CAACyB,KAAD,CAAQzB,CAAC,CAACwB,MAAV,CAAhD,CAAjB,CAEA,IAAK,GAAIhC,CAAAA,CAAC,CAAC,CAAX,CAAaA,CAAC,CAAC,CAAf,CAAiBA,CAAC,EAAlB,CAAsB,CAClB,GAAIwC,CAAAA,IAAI,CAAGD,UAAU,CAACvC,CAAD,CAAV,CAAc,CAAd,CAAX,CACA,GAAIyC,CAAAA,IAAI,CAAGF,UAAU,CAACvC,CAAD,CAAV,CAAc,CAAd,CAAX,CAEA,GAAIM,eAAe,CAACkC,IAAD,CAAOC,IAAP,CAAahC,IAAb,CAAmBC,IAAnB,CAAf,EAA2CoB,SAAS,CAACU,IAAD,CAAT,CAAgBC,IAAhB,GAAuB,CAAtE,CAAyE,CACrEX,SAAS,CAACQ,aAAa,CAACtC,CAAD,CAAb,CAAiB,CAAjB,CAAD,CAAT,CAA+BsC,aAAa,CAACtC,CAAD,CAAb,CAAiB,CAAjB,CAA/B,EAAsD,CAAtD,CACH,CAFD,IAGI,CACAoC,QAAQ,CAACM,IAAT,CAAeL,eAAe,CAACrC,CAAD,CAA9B,EACH,CACJ,CAED,GAAI2C,CAAAA,QAAQ,CAAGzB,cAAc,CAAC,CAAD,CAAImB,eAAe,CAACpC,MAAhB,CAAyB,CAA7B,CAA7B,CAEA,IAAK,GAAID,CAAAA,EAAC,CAAC,CAAX,CAAcA,EAAC,CAACoC,QAAQ,CAACnC,MAAzB,CAAiCD,EAAC,EAAlC,CAAsC,CAClC,GAAIA,EAAC,EAAI2C,QAAT,CAAmB,CACfb,SAAS,CAACM,QAAQ,CAACpC,EAAD,CAAR,CAAY,CAAZ,CAAD,CAAT,CAA0BoC,QAAQ,CAACpC,EAAD,CAAR,CAAY,CAAZ,CAA1B,EAA4C,CAA5C,CACH,CACJ,CACJ,CAED,QAAS4C,CAAAA,wBAAT,CAAmCd,SAAnC,CAA8Cd,SAA9C,CAAyDC,OAAzD,CAAkE4B,CAAlE,CAAqEd,KAArE,CAA4EC,MAA5E,CAAoFvB,IAApF,CAA0FC,IAA1F,CAAgGyB,KAAhG,CAAuG,CACnG,GAAIJ,KAAK,EAAE,CAAP,EAAYC,MAAM,EAAE,CAAxB,CAA2B,CACvB,OACH,CAED,GAAIC,CAAAA,KAAK,CAAGR,YAAY,CAACoB,CAAC,CAAC,CAAD,CAAF,CAAOd,KAAP,CAAxB,CACA,GAAIG,CAAAA,KAAK,CAAGT,YAAY,CAACoB,CAAC,CAAC,CAAD,CAAF,CAAOb,MAAP,CAAxB,CAEA,IAAK,GAAIhC,CAAAA,CAAC,CAAC6C,CAAC,CAAC,CAAD,CAAZ,CAAiB7C,CAAC,CAAG6C,CAAC,CAAC,CAAD,CAAD,CAAKd,KAA1B,CAAiC/B,CAAC,EAAlC,CAAsC,CAClC,GAAIa,UAAU,CAACb,CAAD,CAAIkC,KAAJ,CAAWlB,SAAX,CAAsBC,OAAtB,CAAd,CAA8C,CAC1C,SACH,CAEDa,SAAS,CAAC9B,CAAD,CAAT,CAAakC,KAAb,EAAsB,CAAtB,CACAC,KAAK,CAACO,IAAN,CAAY,CAAC1C,CAAD,CAAIkC,KAAJ,CAAZ,EACH,CAED,IAAK,GAAIlC,CAAAA,GAAC,CAAC6C,CAAC,CAAC,CAAD,CAAZ,CAAiB7C,GAAC,CAAG6C,CAAC,CAAC,CAAD,CAAD,CAAKb,MAA1B,CAAkChC,GAAC,EAAnC,CAAuC,CACnC,GAAIa,UAAU,CAACoB,KAAD,CAAQjC,GAAR,CAAWgB,SAAX,CAAsBC,OAAtB,CAAd,CAA8C,CAC1C,SACH,CAEDa,SAAS,CAACG,KAAD,CAAT,CAAiBjC,GAAjB,EAAsB,CAAtB,CACAmC,KAAK,CAACO,IAAN,CAAY,CAACT,KAAD,CAAQjC,GAAR,CAAZ,EACH,CAED6B,WAAW,CAAEC,SAAF,CAAae,CAAC,CAAC,CAAD,CAAd,CAAmBA,CAAC,CAAC,CAAD,CAApB,CAAyBd,KAAzB,CAAgCC,MAAhC,CAAwCC,KAAxC,CAA+CC,KAA/C,CAAsDzB,IAAtD,CAA4DC,IAA5D,CAAkEyB,KAAlE,CAAX,CAEAS,wBAAwB,CAAEd,SAAF,CAAad,SAAb,CAAwBC,OAAxB,CAAiC4B,CAAjC,CAAoCZ,KAAK,CAACY,CAAC,CAAC,CAAD,CAA3C,CAAgDX,KAAK,CAACW,CAAC,CAAC,CAAD,CAAvD,CAA4DpC,IAA5D,CAAkEC,IAAlE,CAAwEyB,KAAxE,CAAxB,CACAS,wBAAwB,CAAEd,SAAF,CAAad,SAAb,CAAwBC,OAAxB,CAAiC,CAAC4B,CAAC,CAAC,CAAD,CAAF,CAAOX,KAAK,CAAC,CAAb,CAAjC,CAAkDD,KAAK,CAACY,CAAC,CAAC,CAAD,CAAzD,CAA8DA,CAAC,CAAC,CAAD,CAAD,CAAKb,MAAL,CAAYE,KAAZ,CAAkB,CAAhF,CAAmFzB,IAAnF,CAAyFC,IAAzF,CAA+FyB,KAA/F,CAAxB,CACAS,wBAAwB,CAAEd,SAAF,CAAad,SAAb,CAAwBC,OAAxB,CAAiC,CAACgB,KAAK,CAAC,CAAP,CAAUY,CAAC,CAAC,CAAD,CAAX,CAAjC,CAAkDA,CAAC,CAAC,CAAD,CAAD,CAAKd,KAAL,CAAWE,KAAX,CAAiB,CAAnE,CAAsEC,KAAK,CAACW,CAAC,CAAC,CAAD,CAA7E,CAAkFpC,IAAlF,CAAwFC,IAAxF,CAA8FyB,KAA9F,CAAxB,CACAS,wBAAwB,CAAEd,SAAF,CAAad,SAAb,CAAwBC,OAAxB,CAAiC,CAACgB,KAAK,CAAC,CAAP,CAAUC,KAAK,CAAC,CAAhB,CAAjC,CAAqDW,CAAC,CAAC,CAAD,CAAD,CAAKd,KAAL,CAAWE,KAAX,CAAiB,CAAtE,CAAyEY,CAAC,CAAC,CAAD,CAAD,CAAKb,MAAL,CAAYE,KAAZ,CAAkB,CAA3F,CAA8FzB,IAA9F,CAAoGC,IAApG,CAA0GyB,KAA1G,CAAxB,CACH,CAED,QAASW,CAAAA,iBAAT,CAA4B9B,SAA5B,CAAuCC,OAAvC,CAAgDR,IAAhD,CAAsDC,IAAtD,CAA4D,CACxD,GAAIoB,CAAAA,SAAS,CAAG,GAAIiB,CAAAA,KAAJ,CAAUtC,IAAV,CAAhB,CACA,GAAI0B,CAAAA,KAAK,CAAG,EAAZ,CACA,IAAK,GAAInC,CAAAA,CAAC,CAAC,CAAX,CAAaA,CAAC,CAACS,IAAf,CAAoBT,CAAC,EAArB,CAAyB,CACvB8B,SAAS,CAAC9B,CAAD,CAAT,CAAe,GAAI+C,CAAAA,KAAJ,CAAUrC,IAAV,CAAf,CACA,IAAK,GAAIsC,CAAAA,CAAC,CAAC,CAAX,CAAaA,CAAC,CAACtC,IAAf,CAAoBsC,CAAC,EAArB,CAAyB,CACrBlB,SAAS,CAAC9B,CAAD,CAAT,CAAagD,CAAb,EAAkB,CAAlB,CAAoB;AACvB,CACF,CAED;AACA,IAAK,GAAIhD,CAAAA,GAAC,CAAC,CAAX,CAAaA,GAAC,CAACS,IAAf,CAAoBT,GAAC,EAArB,CAAyB,CACrB8B,SAAS,CAAC9B,GAAD,CAAT,CAAa,CAAb,EAAkB,CAAlB,CACAmC,KAAK,CAACO,IAAN,CAAY,CAAC1C,GAAD,CAAI,CAAJ,CAAZ,EAEA8B,SAAS,CAAC9B,GAAD,CAAT,CAAaU,IAAI,CAAC,CAAlB,EAAuB,CAAvB,CACAyB,KAAK,CAACO,IAAN,CAAY,CAAC1C,GAAD,CAAIU,IAAI,CAAC,CAAT,CAAZ,EACH,CAED;AACA,IAAK,GAAIsC,CAAAA,EAAC,CAAC,CAAX,CAAaA,EAAC,CAACtC,IAAf,CAAoBsC,EAAC,EAArB,CAAyB,CACrBlB,SAAS,CAAC,CAAD,CAAT,CAAakB,EAAb,EAAkB,CAAlB,CACAb,KAAK,CAACO,IAAN,CAAY,CAAC,CAAD,CAAIM,EAAJ,CAAZ,EAEAlB,SAAS,CAACrB,IAAI,CAAC,CAAN,CAAT,CAAkBuC,EAAlB,EAAuB,CAAvB,CACAb,KAAK,CAACO,IAAN,CAAY,CAACjC,IAAI,CAAC,CAAN,CAASuC,EAAT,CAAZ,EACH,CAEDJ,wBAAwB,CAAEd,SAAF,CAAad,SAAb,CAAwBC,OAAxB,CAAiC,CAAC,CAAD,CAAI,CAAJ,CAAjC,CAAyCR,IAAI,CAAC,CAA9C,CAAiDC,IAAI,CAAC,CAAtD,CAAyDD,IAAzD,CAA+DC,IAA/D,CAAqEyB,KAArE,CAAxB,CAEA,IAAK,GAAInC,CAAAA,GAAC,CAAC,CAAX,CAAaA,GAAC,CAACS,IAAf,CAAoBT,GAAC,EAArB,CAAyB,CACrB,IAAK,GAAIgD,CAAAA,GAAC,CAAC,CAAX,CAAaA,GAAC,CAACtC,IAAf,CAAoBsC,GAAC,EAArB,CAAyB,CACrB,GAAI5C,KAAK,CAAC+B,KAAD,CAAQ,CAACnC,GAAD,CAAIgD,GAAJ,CAAR,CAAL,EAAwBlB,SAAS,CAAC9B,GAAD,CAAT,CAAagD,GAAb,GAAiB,CAA7C,CAAgD,CAC5Cb,KAAK,CAAGxC,SAAS,CAACwC,KAAD,CAAQ,CAACnC,GAAD,CAAIgD,GAAJ,CAAR,CAAjB,CACH,CACJ,CACJ,CAED,MAAOb,CAAAA,KAAP,CACH,CAED,cAAeW,CAAAA,iBAAf","sourcesContent":["function deleteRow(arr, row) {\n  let pos = undefined;\n  for( let i=0;i<arr.length;i++ ){\n    if( arr[i][0]==row[0] && arr[i][1]==row[1] ){\n      pos = i;\n    }\n  }\n  \n  pos += 1;\n  \n  arr = arr.slice(0); \n  arr.splice(pos - 1, 1);\n  return arr;\n}\n  \nfunction check( arr, num ){\n  for( let i=0;i<arr.length;i++ ){\n    if( arr[i][0]==num[0] && arr[i][1]==num[1] ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nfunction isWithinTheGrid( x, y, rows, cols ){\n    let condition1 = (x >= 0)&&(x < rows);\n    let condition2 = (y >= 0)&&(y < cols);\n    return (condition1 && condition2);\n}\n\nfunction isStartEnd( posX, posY, startNode, endNode ){\n    let condition1 = (startNode.x == posX)&&(startNode.y == posY);\n    let condition2 = (endNode.x == posX)&&(endNode.y == posY);\n\n    return (condition1 || condition2);\n}\n\nfunction generateNumber( min, max ){\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1) + min); \n}\n\nfunction getWallIndex( corner, size ){\n    let wallPos = undefined;\n    if( size >= 3 ){\n        wallPos = generateNumber(corner+1, corner+size-2);\n        if( wallPos%2 == 1 ){\n            wallPos -= 1;\n        }\n\n        return wallPos;\n    }\n    else{\n        return ;\n    }\n}\n\nfunction makeOpening( psudoGrid, x, y, width, heigth, wallX, wallY, rows, cols, walls ){\n    //Total openings\n    let openings = [];\n    \n    //Possible Opening\n    let possibleOpening = [ [generateNumber(x, wallX-1), wallY], [generateNumber(wallX+1, x+width-1), wallY], [wallX, generateNumber(y, wallY-1)], [wallX, generateNumber(wallY+1, y+heigth-1)] ];\n    \n    //Margin Opening\n    let marginOpening = [ [x, wallY], [x+width-1, wallY], [wallX, y], [wallX, y+heigth-1] ];\n\n    //Adjecent opening\n    let adjOpening = [ [x-1, wallY], [x+width, wallY], [wallX, y-1], [wallX, y+heigth] ];\n\n    for( let i=0;i<4;i++ ){\n        let adjX = adjOpening[i][0];\n        let adjY = adjOpening[i][1];\n\n        if( isWithinTheGrid(adjX, adjY, rows, cols) && psudoGrid[adjX][adjY]==0 ){\n            psudoGrid[marginOpening[i][0]][marginOpening[i][1]] = 0;\n        }\n        else{\n            openings.push( possibleOpening[i] );\n        }\n    }\n\n    let ignoreIt = generateNumber(0, possibleOpening.length - 1);\n\n    for( let i=0; i<openings.length; i++ ){\n        if( i != ignoreIt ){\n            psudoGrid[openings[i][0]][openings[i][1]] = 0;\n        }\n    }\n}\n\nfunction recursiveDivision_helper( psudoGrid, startNode, endNode, d, width, heigth, rows, cols, walls ){\n    if( width<=1 || heigth<=1 ){\n        return;\n    }\n\n    let wallX = getWallIndex(d[0], width);\n    let wallY = getWallIndex(d[1], heigth);\n\n    for( let i=d[0]; i < d[0]+width; i++ ){\n        if( isStartEnd(i, wallY, startNode, endNode) ){\n            continue;\n        }\n\n        psudoGrid[i][wallY] = 1;\n        walls.push( [i, wallY] );\n    }\n\n    for( let i=d[1] ;i < d[1]+heigth ;i++ ){\n        if( isStartEnd(wallX, i, startNode, endNode) ){\n            continue;\n        }\n\n        psudoGrid[wallX][i] = 1;\n        walls.push( [wallX, i] );\n    }\n\n    makeOpening( psudoGrid, d[0], d[1], width, heigth, wallX, wallY, rows, cols, walls );\n\n    recursiveDivision_helper( psudoGrid, startNode, endNode, d, wallX-d[0], wallY-d[1], rows, cols, walls );\n    recursiveDivision_helper( psudoGrid, startNode, endNode, [d[0], wallY+1], wallX-d[0], d[1]+heigth-wallY-1, rows, cols, walls );\n    recursiveDivision_helper( psudoGrid, startNode, endNode, [wallX+1, d[1]], d[0]+width-wallX-1, wallY-d[1], rows, cols, walls );\n    recursiveDivision_helper( psudoGrid, startNode, endNode, [wallX+1, wallY+1], d[0]+width-wallX-1, d[1]+heigth-wallY-1, rows, cols, walls );\n}\n\nfunction recursiveDivision( startNode, endNode, rows, cols ){\n    let psudoGrid = new Array(rows);\n    let walls = [];\n    for( let i=0;i<rows;i++ ){\n      psudoGrid[i] = new Array(cols);\n      for( let j=0;j<cols;j++ ){\n          psudoGrid[i][j] = 0;// 0 indicates empty\n      } \n    }    \n\n    //Marking the boudries as walls\n    for( let i=0;i<rows;i++ ){\n        psudoGrid[i][0] = 1;\n        walls.push( [i, 0] );\n\n        psudoGrid[i][cols-1] = 1;\n        walls.push( [i, cols-1] );\n    }\n\n    //Marking the boudries as walls\n    for( let j=0;j<cols;j++ ){\n        psudoGrid[0][j] = 1;\n        walls.push( [0, j] );\n\n        psudoGrid[rows-1][j] = 1;\n        walls.push( [rows-1, j] );\n    }\n\n    recursiveDivision_helper( psudoGrid, startNode, endNode, [1, 1], rows-2, cols-2, rows, cols, walls );\n\n    for( let i=0;i<rows;i++ ){\n        for( let j=0;j<cols;j++ ){\n            if( check(walls, [i, j]) && psudoGrid[i][j]==0 ){\n                walls = deleteRow(walls, [i, j] );\n            }\n        }\n    }\n\n    return walls;\n}\n\nexport default recursiveDivision;\n"]},"metadata":{},"sourceType":"module"}